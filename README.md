Required Software
-	Ubuntu 14.04 LTS.
-	Python 3
-	bitstring (Use pip3 to install)
Instructions
You will be these few files in this experiment:
1.	coffee_test_002_sender.py – to send the encoded packets to receiver.
2.	coffee_test_002_receiver.py – to receive the encoded packets.
3.	Precoder.py – to generate the pre-encoded sample files. It will be explained later.
4.	text??k.txt – the random ASCII sample. 
5.	text??k_ss2048.txt.p – this is the file generated by Precoder.py. It will be explained later.
The rest of the files are not important at this stage.

1. Sample Files
To start the experiment, you need to a few sample files. The contents of the files are not important – they are used to test the transmission speed only. I have prepared a few sample files of 10KB to 500KB. If you need to have other size of sample file, you can generate it with 
base64 /dev/urandom | head -c 10M > file.txt
where the “10M” stands for 10MB (1KB is 1024 bytes). 

2. Pre-encoded Sample Files
All the sample files have to be pre-encoded. The reason is because the time for Python to generate one encoded packet may slow down the throughput.
First you have to determine the symbol size – in this experiment I think it is rationale to assume the packet size as 2048 bytes as I notice the TCP packets to Victoria PC are 20xx bytes too. 
To pre-encode the sample files, type “python3 Precoder.py -f [filename] -l [packet /symbol size]
	python3 Precoder.py -f text10k.txt -l 2048
and you will see the total message symbols if the sample file is encoded using the said symbol size. For example, we have total of 5 message symbols if we pre-encode the sample file of 10kB with symbol size of 2048 bytes. The screen shot is as the following.  
  
I have generated the pre-encoded sample files for 10kB to 500kB. If you need larger sample, you have to generate them using the aforementioned method.

3. Sender and Receiver of TCP
Please skip this step if you do not need to measure the TCP transmission time. But I think you need this for the comparison with UDP-RC.
Firstly, start the TCP receiver at the remote server (using SSH):
nc -l -p 20000 > out.file
where –l set the listening address and port, 20000 is the port number out.file is just the temporary filename (not important).

Secondly, start the sender using the following line:
time nc -w 3 103.196.108.20 20000 < text100K.txt
where “time” is to measure the running time, -w 3 is the controlling parameter (not important to you), the address, the port and the sample file “text100k.txt”. Please you the different sample file of different size depending on your experiment. 

4. Sender and Receiver of UDP-RC
The sender and receiver of the UDP-RC scripts are coffee_test_002_sender.py and coffee_test_002_receiver.py. They are written in Python using a lot of threads and are not optimized. 
Firstly, we have to start the UDP-RC receiver at the remote server (ssh). Run:
python3 coffee_test_002_receiver.py -a 103.196.108.20 -p 10000 –d 0
where, -a [address], –p [port number], and –d [debugging level].

Secondly, we will call the sender to start sending file with :
time python3 coffee_test_002_sender.py -a 103.196.108.20 -p 10000 -t 10 -f text100k_ss2048.txt.p –d 0
where, the “time” is needed to measure the total running time, -a [address], -p [port number], -f [pre-encoded sample file in .p], -t [the packet delay in ms] and –d [debugging level].
The delay is here in order to control the transmission rate. UDP-RC, at least in this script, does not have an intelligent algorithm to control the transmission rate. So, the –t delay will be used to ensure the transmission rate is lower than the capacity of the link. The value of –t delay is not calculate-able at this stage – it is based on the repeatedly attempt for the values in between 10 to 30 (at least at my side). For sure, there is a –t value where it will give you the lowest transmission time. 


